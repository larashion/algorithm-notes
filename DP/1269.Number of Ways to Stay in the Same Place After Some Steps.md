机器人可以有三种选择留在原地、左移一步、右移一步

steps步之后多少种走法使机器人留在原地？

`1 <= steps <= 500`    
`1 <= arrLen <= 10^6`

可以看出依赖关系是上一排的pos-1、pos、pos+1之和

naive DFS ：TLE

```java
class Solution {
    public int numWays(int steps, int arrLen) {
        return dfs(0, steps, arrLen);
    }

    int dfs(int pos, int steps, int arrLen) {
        if (steps == 0) {
            return pos == 0 ? 1 : 0;
        }
        int mod = (int) 1e9 + 7; 
        int res = 0;
        res = (res + dfs(pos, steps - 1, arrLen)) % mod;
        if (pos > 0) res = (res + dfs(pos - 1, steps - 1, arrLen)) % mod;
        if (pos + 1 < arrLen) res = (res + dfs(pos + 1, steps - 1, arrLen)) % mod;
        return res;
    }
}
```

一定要进行优化：想回到0点就不能跑太远，arrLen可是百万级别！

应当返回dp【steps】【0】因为要求的是能到达0位置的方案数

从step = 1开始枚举即可

DP

```java
class Solution {
    public int numWays(int steps, int arrLen) {
        int n = Math.min(steps / 2 + 1, arrLen);
        int mod = (int) 1e9 + 7;
        long[][] dp = new long[steps + 1][n];
        dp[0][0] = 1;
        for (int i = 1; i < steps + 1; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = (dp[i - 1][j] + (j + 1 < n ? dp[i - 1][j + 1] : 0) + (j > 0 ? dp[i - 1][j - 1] : 0)) % mod;
            }
        }
        return (int) dp[steps][0];
    }
}
```

space compression


```java
class Solution {
    public int numWays(int steps, int arrLen) {
        int n = Math.min(steps / 2 + 1, arrLen);
        int mod = (int) 1e9 + 7;
        long[][] dp = new long[2][n];
        dp[0][0] = 1;
        for (int i = 1; i < steps + 1; i++) {
            for (int j = 0; j < n; j++) {
                dp[i & 1][j] = (dp[i - 1 & 1][j] + (j + 1 < n ? dp[i - 1 & 1][j + 1] : 0) + (j > 0 ? dp[i - 1 & 1][j - 1] : 0)) % mod;
            }
        }
        return (int) dp[steps & 1][0];
    }
}
```