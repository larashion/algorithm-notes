在n x n 的西洋棋盘上有一棋子“马”，给定起点坐标，求棋子跳k步后仍在棋盘内的概率。

试想棋子在k+1层高的魔方中跳跃，棋子初始位于第k层，每跳跃一次就降低一层，耗尽跳跃点数为止。当棋子位于第0层就结束，棋子初始时一定在棋盘内

逐层倒推算出从起始点的出发跳跃k步仍在棋盘内的概率

可以先通过DFS拼出DP的位置依赖思路，再改成DP即可

#### dfs

深搜，并且用三维数组作缓存，递归终止条件：跳跃次数为 0 就返回1，另外如果越界就不进入递归

将坐标加上偏移量，跳跃次数减一，带入一下层递归

累加结果要除以8 ，因为只有八分之一概率跳往该方向

go

```go
func knightProbability(n int, k int, row int, column int) float64 {
	visited := make([][][]float64, n)
	for i := range visited {
		visited[i] = make([][]float64, n)
		for j := range visited[i] {
			visited[i][j] = make([]float64, k+1)
		}
	}
	return DFS(n, k, row, column, visited)
}
func DFS(n, k, i, j int, visited [][][]float64) float64 {
	dirs := [8][2]int{{-2, 1}, {-2, -1}, {-1, 2}, {-1, -2}, {1, 2}, {1, -2}, {2, -1}, {2, 1}}
	if k == 0 {
		return 1
	}
	if visited[i][j][k] > 0 {
		return visited[i][j][k]
	}
	res := 0.0
	for _, dir := range dirs {
		x := i + dir[0]
		y := j + dir[1]
		if x > n-1 || y > n-1 || x < 0 || y < 0 {
			continue
		}
		res += DFS(n, k-1, x, y, visited) / 8
	}
	visited[i][j][k] = res
	return res
}
```

#### dp

```go
func knightProbability(n int, k int, row int, column int) float64 {
	dirs := [8][2]int{{-2, 1}, {-2, -1}, {-1, 2}, {-1, -2}, {1, 2}, {1, -2}, {2, -1}, {2, 1}}
	dp := make([][][]float64, k+1)
	for i := range dp {
		dp[i] = make([][]float64, n)
		for j := range dp[i] {
			dp[i][j] = make([]float64, n)
		}
	}
	for i := range dp[0] {
		for j := range dp[0][i] {
			dp[0][i][j] = 1
		}
	}
	for steps := 1; steps < k+1; steps++ {
		for i := range dp[steps] {
			for j := range dp[steps][0] {
				for _, dir := range dirs {
					x := i + dir[0]
					y := j + dir[1]
					if x < n && x >= 0 && y < n && y >= 0 {
						dp[steps][i][j] += dp[steps-1][x][y] / 8
					}
				}
			}
		}
	}
	return dp[k][row][column]
}
```

#### 2Ddp

空间压缩在本题也适用，从第1层开始DP，仅保存前一层的数据

go

```go
func knightProbability(n int, k int, row int, column int) float64 {
	dirs := [8][2]int{{-2, 1}, {-2, -1}, {-1, 2}, {-1, -2}, {1, 2}, {1, -2}, {2, -1}, {2, 1}}
	dp := [2][][]float64{}
	for i := range dp {
		dp[i] = make([][]float64, n)
		for j := range dp[i] {
			dp[i][j] = make([]float64, n)
		}
	}
	fill(dp[0], 1)
	for l := 1; l < k+1; l++ {
		fill(dp[l&1], 0)
		for i := range dp[0] {
			for j := range dp[0][0] {
				for _, dir := range dirs {
					x := i + dir[0]
					y := j + dir[1]
					if x < n && x >= 0 && y < n && y >= 0 {
						dp[l&1][i][j] += dp[(l-1)&1][x][y] / 8
					}
				}
			}
		}
	}
	return dp[k&1][row][column]
}
func fill(curr [][]float64, val float64) {
	for i := range curr[0] {
		for j := range curr[0] {
			curr[i][j] = val
		}
	}
}
```

java

```java
public class Solution {
    public double knightProbability(int n, int k, int r, int c) {
        int[][] dirs = new int[][]{{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};
        float[][][] dp = new float[2][n][n];
        fill(dp[0], 1);
        for (int l = 1; l < k + 1; l++) {
            fill(dp[l & 1], 0);
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    for (int[] dir : dirs) {
                        int x = i + dir[0];
                        int y = j + dir[1];
                        if (x >= n || x < 0 || y >= n || y < 0) continue;
                        dp[l & 1][i][j] += dp[l - 1 & 1][x][y] / 8;
                    }
                }
            }
        }
        return dp[k & 1][r][c];
    }

    void fill(float[][] curr, float val) {
        for (float[] floats : curr) {
            Arrays.fill(floats, val);
        }
    }
}
```